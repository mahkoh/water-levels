\documentclass[11pt,a4paper]{article}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{xltxtra}
\usepackage{parskip}
\usepackage{svg}
\usepackage{esint}
\usepackage[]{algpseudocode}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{rem}{Remark}
\newtheorem{defi}{Definition}
\newtheorem{ex}{Example}
\newtheorem{nota}{Notation}

\newcommand{\inv}[1]{\frac{1}{#1}}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Np}{\mathbb{N}_+}
\newcommand{\bO}{\mathcal{O}}
\newcommand{\Rp}{\mathbb{R}_+}
\newcommand{\Rnn}{\mathbb{R}_{\ge0}}

\DeclareMathOperator{\capp}{cap}
\DeclareMathOperator{\ot}{ot}
\DeclareMathOperator{\Fill}{fill}
\DeclareMathOperator{\filltime}{filltime}

\makeatletter
\def\thm@space@setup{\thm@preskip=\parskip \thm@postskip=0pt}
\makeatother

\begin{document}

\begin{nota}
  We write
  \begin{itemize}
    \item $\Rp = (0, \infty)$ for the set of positive real numbers,
    \item $\Rnn = [0, \infty)$ for the set of non-negative real numbers, and
    \item $\Np = \{ 1, 2, \ldots \}$ for the set of positive natural numbers.
  \end{itemize}
\end{nota}

Let $n\in\Np$ and let  $(e_1, \ldots, e_n) \in \Rp^n$ be a finite sequence describing the elevation levels of a terrain.
Assume that each $e_i$ describes a segment with a width of $1$ unit.

Assume that it is raining and that each segment receives $1$ square unit of water per hour.
The task is to find an algorithm that outputs the elevation of each segment after $T\in\Rp$ hours while taking into account the effects of gravity.

\begin{ex}
  The following terrain could be described by the sequence $10, 30, 50, 70, 90, 0, 70, 50$.
  \begin{center}
    \includegraphics{im1.pdf}
  \end{center}
  After $16$ hours it would then look as follows with the elevations being $54, 54, 54, 70, 90, 36, 70, 70$.
  \begin{center}
    \includegraphics{im2.pdf}
  \end{center}
\end{ex}

In the following we will no longer assume that each $e_i$ describes a segment with a width of $1$ unit.
Instead, let $w_1,\ldots,w_n \in \Rp$ with $w_i > 0$ be a sequence describing the width of the segments.
The original problem can then be solved by setting $w_i = 1$.

\begin{defi}
  Let $n\in\Np$.
  We say that $(e_1,\ldots,e_n)$ is an elevation sequence with widths $(w_1,\ldots,w_n)$ if
  $(e_1,\ldots,e_n) \in \Rnn^n$ and $(w_1,\ldots,w_n) \in \Rp^n$.
\end{defi}

In our generalized setting, each segment $i$ receives $w_i$ square units of water per hour.

Note that the problem is invariant under splitting of segments and merging of adjacent segments with identical elevation.

By splitting we mean replacing $e_i$ in place by $e_{i,1} = e_{i,2} = e_i$ and $w_i$ by $w_{i,1}, w_{i,2}$ with $w_{i,1} + w_{i,2} = w_i$.

By merging we mean replacing $e_i, e_{i+1}$ with $e_i = e_{i+1}$ in place by $\hat{e}_i = e_i$ and $w_i, w_{i+1}$ by $\hat{w}_i = w_i + w_{i+1}$.

\begin{defi}
    Let $n\in\Np$ and let $(e_1,\ldots,e_n)$ be an elevation sequence.
    \begin{enumerate}
    \item We say that $(e_1,\ldots,e_n)$ is fully merged if $e_i \ne e_{i+1}$ for all $i\in\{1,\ldots,n - 1\}$.
    \item Let $m\in\Np$ and let $(\tilde{e}_1,\ldots,\tilde{e}_m)$ be an elevation sequence.
        We say that $(e_1,\ldots,e_n)$ and $(\tilde{e}_1,\ldots,\tilde{e}_m)$ are equivalent if the fully merged versions of both sequences are identical.
    \item We say that $(e_1,\ldots,e_n)$ has a single local minimum if there is an
    $i\in\{1,\ldots,n\}$ such that $e_1,\ldots,e_i$ is monotonically decreasing and $e_i,\ldots,e_n$ is monotonically increasing.
    \item Assume that $(e_1,\ldots,e_n)$ is fully merged.
        Let $i\in\{2,\ldots,n-1\}$.
        We say that $e_i$ is a local maximum if $e_{i-1}<e_i$ and $e_i>e_{i+1}$.
    \end{enumerate}
\end{defi}

\begin{ex}
  The following terrain has a single local minimum:
  \begin{center}
    \includegraphics{im3.pdf}
  \end{center}
  But this one has multiple local minima:
  \begin{center}
    \includegraphics{im4.pdf}
  \end{center}
\end{ex}

\begin{lem}
    Let $n\in\Np$ and let $(e_1,\ldots,e_n)$ be an elevation sequence.
    The fully merged version of $(e_1,\ldots,e_n)$ can be computed in $\bO(n)$ time.
\end{lem}

\begin{proof}
    Iterate over the $e_i$ in ascending order.
    If $e_{i+1} = e_i$, merge the two elements.
    Otherwise move to the next element.
\end{proof}

\begin{lem}
  Let $n,m\in\Np$, $m < n$, and let $(e_1,\ldots,e_n), (\hat{e}_1,\ldots,\hat{e}_m)$ be equivalent elevation sequences. Let
  \begin{align*}
      x \in \left[0, \sum_{i=1}^n w_i\right)
  \end{align*}
  be a point in the terrain.
  The elevation level at $x$ can be determined from $(e_1,\ldots,e_n)$, $(\hat{e}_1,\ldots,\hat{e}_m)$ in $\bO(n)$ time and this process yields the same value for both sequences.

  For $l\in\Np$ and $x_1,\ldots,x_l$ as above, the elevation levels at these points can be determined
  in $\bO(\max(l\log(l), n))$ time.
\end{lem}

\begin{proof}
    It is sufficient to assume that $(\hat{e}_1,\ldots,\hat{e}_m)$ is the fully merged version of $(e_1,\ldots,e_n)$.

    We can determine in $\bO(n)$ time the smallest $j$ such that $\sum_{i=1}^j w_i > x$.
    Then the elevation level is $e_j$.

    We can transform $(\hat{e}_1,\ldots,\hat{e}_m)$ into $(e_1,\ldots,e_n)$ by performing a finite number of splitting steps.
    Assume that it takes a single step such that $(e_1,\ldots,e_k,e_{k+1},\ldots,e_n) = (\hat{e}_1,\ldots,\hat{e}_k,\hat{e}_k,\ldots,\hat{e}_m)$ for some $k\in{1,\ldots,m}$.

    If $r<k$ then $\sum_{i=1}^r \hat{w}_i = \sum_{i=1}^r w_i$.
    If $r\ge k$ then $\sum_{i=1}^r \hat{w}_i = \sum_{i=1}^{r+1} w_i$.

    Let $\hat{j}$ be the smallest integer such that $\sum_{i=1}^{\hat{j}} \hat{w}_i > x$.

    If $\hat{j}<k$ then $\sum_{i=1}^{\hat{j}} w_i = \sum_{i=1}^{\hat{j}} \hat{w}_i > x$, hence $k > \hat{j} \ge j$ by the definition of $j$.
    Furthermore $\sum_{i=1}^j \hat{w}_i = \sum_{i=1}^j w_i > x$, hence $j \ge \hat{j}$ by the definition of $\hat{j}$. 
    Therefore $j = \hat{j} < k$ and $e_j = e_{\hat{j}} = \hat{e}_{\hat{j}}$.

    If $\hat{j}=k$ then $\sum_{i=1}^{k-1} w_i = \sum_{i=1}^{k-1} \hat{w}_i \le x$.
    Hence $j\ge k$ by the definition of $j$.
    Furthermore: $\sum_{i=1}^{k+1} w_i = \sum_{i=1}^k \hat{w}_i > x$.
    Hence $j\le k+1$ by the definition of $j$.
    However, by our assumption $e_k = e_{k+1} = \hat{e}_k$.
    Therefore $e_j = \hat{e}_{\hat{j}}$.

    If $\hat{j}>k$ then $\sum_{i=1}^{\hat{j}+1} w_i = \sum_{i=1}^{\hat{j}} \hat{w}_i > x$.
    Hence $j\le \hat{j}+1$ by the definition of $j$.
    Furthermore $\sum_{i=1}^{\hat{j}} w_i = \sum_{i=1}^{\hat{j}-1} \hat{w}_i \le x$ by the definition of $\hat{j}$.
    Hence $j > \hat{j}$ by the definition of $j$.
    Therefore $j = \hat{j}+1$ and $e_j = e_{\hat{j}+1} = \hat{e}_{\hat{j}}$.

    The case where there is more than one splitting step now follows immediately by induction.

    For the $x_1,\ldots,x_l$, we can first assume that they are sorted in ascending order by applying a sorting algorithm in $l\log(l)$ time.
    Then we iterate over the $x_i$ and apply the algorithm above except that, since the $x_i$ are sorted, we do not have to restart the summation for each $x_i$.
    Hence, this iteration completes in $\bO(max(l, n))$ time.
\end{proof}

\begin{lem}
  Let $n\in\Np$, $T\in\Rnn$, and let $(e_1,\ldots,e_n)$ be an elevation sequence with widths $1$.
  Assume that we have an algorithm that produces the elevation of the terrain after $T$ hours of rain in form of an elevation sequence with $m \le 2n$ segments in $\bO(n\log(n))$ time.
  Then we can determine the solution to the original problem in $\bO(n\log(n))$ time.
\end{lem}

\begin{proof}
  Let $(x_1,\ldots,x_n) = (0,\ldots,n-1)$.
  By applying the algorithm from the previous lemma to the output of the algorithm from this lemma,
  we determine the elevation levels at the points $x_i$ in $\bO(\max(n\log(n), 2n)) = \bO(n\log(n))$ time.
\end{proof}

\begin{lem}
  Let $n\in\Np$ and let $(e_1,\ldots,e_n)$ be a fully merged elevation sequence.
  The following statements are equivalent:
  \begin{enumerate}
    \item $(e_1,\ldots,e_n)$ has a single local minimum.
    \item $(e_1,\ldots,e_n)$ has no local maxima.
  \end{enumerate}
\end{lem}

\begin{proof}
  $\Rightarrow$: Assume that $(e_1,\ldots,e_n)$ has a single local minimum $e_i$.
  For $i \le j < k$, $e_j \le e_k$, therefore $e_j$ is not a local maximum.
  For $k > j \ge i$, $e_k \ge e_j$, therefore $e_j$ is not a local maximum.

  $\Leftarrow$: Assume that $(e_1,\ldots,e_n)$ has no local maxima.
  Let $i$ such that $e_i = \min(e_1,\ldots,e_n)$.
  We show by induction over $j \in \{i,\ldots,n-1\}$ that $e_j < e_{j+1}$.
  For $j = i$ it follows by the definition of $i$ and the fact that the sequence is fully merged.
  Assume that the statement holds for $j-1$, that is, $e_{j-1} < e_j$.
  If $e_j > e_{j+1}$, then $e_j$ would be a local maximum.
  Since this is not possible, $e_j < e_{j+1}$.
  By an identical induction, we see that $e_{j-1} > e_j$ for $j \in \{2,\ldots,i\}$.
\end{proof}

In the first step, we will look at the case where the terrain has a single local minimum.

\begin{lem}
    \label{alg1}
    Let $n\in\Np$, $V\in\Rnn$, and let $(e_1,\ldots,e_n)$ be a fully merged elevation sequence with a single local minimum.
    The following algorithm calculates the elevation levels after pouring $V$ square units of water into the terrain.
    The algorithm runs in $\bO(n)$ time.
\end{lem}

\vspace{1em}

\begin{algorithmic}[1]
    \State Let $i$ be such that $e_i$ is the local minimum of the sequence\; \label{a1:minimum}
    \State For all $j$, $e_j^0 := e_j$ and $w_j^0 := w_j$
    \State $i^0 := i$
    \State $n^0 := n$
    \State $K := 0$
    \While{true} \label{a1:while}
        \State $l := \infty$
        \If{$i^K > 1$}
            \State $l := e_{i^K-1}^K$
        \EndIf
        \State $r := \infty$
        \If{$i^K < n^K$}
            \State $r := e_{i^K+1}^K$
        \EndIf
        \State $m := \min(l, r)$
        \State $u := (m-e_{i^K}^K)w_{i^K}$
        \If{$V < u$} \label{a1:vleu}
            \State $e_{i^K}^K := e_{i^K}^K + \frac{V}{w_{i^K}}$ \label{a1:vplus}
            \State break \label{a1:break}
        \EndIf
        \State $e_{i^K}^K := m$ \label{a1:newe}
        \If{$l = r$} \label{a1:leqr}
            \State $n^{K+1} := n^K - 2$ \label{a1:min2}
        \Else
            \State $n^{K+1} := n^K - 1$ \label{a1:min1}
        \EndIf
        \State Merge $e_{i^K}^K$ with the surrounding segments if possible \label{a1:merge}
        \State Call the resulting sequence $e_1^{K+1},\ldots,e_{n^{K+1}}^{K+1}$ and $w_1^{K+1},\ldots,w_{n^{K+1}}^{K+1}$
        \If{$l \le r$} \label{a1:ller}
            \State $i^{K+1} := i^K - 1$ \label{a1:imin1}
        \Else
            \State $i^{K+1} := i^K$ \label{a1:imin0}
        \EndIf
        \State $K := K + 1$
        \State $V := V - u$
    \EndWhile
    \State The $e_1^K,\ldots,e_{n^K}^K$ are the elevation levels
\end{algorithmic}

\begin{proof}
The proof consists of 4 parts. In part 1 we show that the algorithm is well-formed.
In part 2 we show that it can be expressed recursively.
In part 3 we show that it computes the water levels.
In part 4 we show that it runs in $\bO(n)$ time.

\textbf{Part 1}: By induction over $K$ we show that $i^K \le n^K$ and that $n^{K+1}$ is in fact the length of the sequence after the merge step in line \ref{a1:merge}.
Note that we only show it for those finitely many $K$ that appear in the algorithm.

For $K=0$ it is clear.
Assume that the condition holds for $K = \tilde{K}$ and that we have started the loop with $K$ set to this value.
If $V < u$ holds in line \ref{a1:vleu}, then the loop ends and it is nothing to show.
Otherwise assume that $V \ge u$.

If $l = r$ in line \ref{a1:leqr}, then $(l - e_{i^K}^K)w_{i^K} = (\min(l,r) - e_{i^K}^K)w_{i^K} = (m - e_{i^K}^K)w_{i^K} = u \le V < \infty$.
Therefore, since $w_{i^K} > 0$, $l = r < \infty$.
By the definitions of $l$ and $r$, it follows that $i^K > 1$ and $i^K < n^K$ and therefore
$e_{i^K-1}^K = l = r = e_{i^K+1}^K$.
After setting $e_{i^K}^K := m = l = r$ in line \ref{a1:newe}, the merge step in line \ref{a1:merge} merges $e_{i^K - 1}^K, e_{i^K}^K$, and $e_{i^K + 1}^K$.
Therefore the resulting sequence contains two fewer elements and the assignment $n^{K+1} := n^K - 2$ in line \ref{a1:min2} was correct.
Furthermore, in line \ref{a1:imin1}, $i^{K+1} := i^K - 1 \le n^K - 1 - 1 = n^{K+1}$.

Otherwise if $l < r$ then $l < \infty$ and $i^K > 1$ and therefore $e_{i^K-1}^K = l$.
After setting $e_{i^K}^K := m = l$ in line \ref{a1:newe}, the merge step in line \ref{a1:merge} merges $e_{i^K - 1}^K$ and $e_{i^K}^K$.
Therefore the resulting sequence contains one fewer element and the assignment $n^{K+1} := n^K - 1$ in line \ref{a1:min1} was correct.
Furthermore, in line \ref{a1:imin1}, $i^{K+1} := i^K - 1 \le n^K - 1 = n^{K+1}$.

Otherwise if $l > r$ then $r < \infty$ and $i^K < n^K$ and therefore $e_{i^K+1}^K = r$.
After setting $e_{i^K}^K := m = r$ in line \ref{a1:newe}, the merge step in line \ref{a1:merge} merges $e_{i^K}^K$ and $e_{i^K + 1}^K$.
Therefore the resulting sequence contains one fewer element and the assignment $n^{K+1} := n^K - 1$ in line \ref{a1:min1} was correct.
Furthermore, in line \ref{a1:imin0}, $i^{K+1} := i^K \le n^K - 1 = n^{K+1}$.

This completes the proof by induction.

\textbf{Part 2}: By induction over $K$ we show that the sequence $e_1^K,\ldots,e_{n^K}^K$ is fully merged and has a single local minimum, and that $e_{i^K}^K$ is the local minimum of the sequence.

For $K=0$ it is clear.
Assume that the condition holds for $K = \tilde{K}$ and that we have started the loop with $K$ set to this value.
If $V < u$ holds in line \ref{a1:vleu}, then $e_{i^K}^K := e_{i^K}^K + \frac{V}{w_{i^K}} < e_{i^K}^K + \frac{u}{w_{i^K}} = m = \min(l, r)$.
Hence, $e_{i^K}^K < \min(l, r)$ and $e_{i^K}^K$ remains the strict minimum of the sequence.
Otherwise assume that $V \ge u$.

If $l \le r$ in line \ref{a1:ller}, then $e_{i^K}^K := m = l$ in line \ref{a1:newe} and the merge step in line \ref{a1:merge} merges $e_{i^K - 1}^K$ and $e_{i^K}^K$.
Since we set $i^{K+1} := i^K - 1$ in line \ref{a1:imin1},
$(e_1^{K+1},\ldots,e_{i^{K+1}}^{K+1}) = (e_1^K,\ldots,e_{i^K - 1}^K)$ is strictly monotonically decreasing by induction.
If $l < r$, then $(e_{i^{K+1}}^{K+1},\ldots,e_{n^{K+1}}^{K+1}) = (l,r,\ldots,e_{n^K}^K)$ is strictly monotonically increasing.
Otherwise if $l = r$, then $(e_{i^{K+1}}^{K+1},\ldots,e_{n^{K+1}}^{K+1}) = (r,e_{i^K+2}^K,\ldots,e_{n^K}^K)$ is strictly monotonically increasing.
(Note that in the case $l = r$ we merge 3 segments.)

If $l > r$ in line \ref{a1:ller}, then $e_{i^K}^K := m = r$ in line \ref{a1:newe} and the merge step in line \ref{a1:merge} merges $e_{i^K}^K$ and $e_{i^K + 1}^K$.
Since we set $i^{K+1} := i^K$ in line \ref{a1:imin1},
$(e_1^{K+1},\ldots,e_{i^{K+1}}^{K+1}) = (e_1^K,\ldots,l,r)$ is strictly monotonically decreasing by induction.
Furthermore $(e_{i^{K+1}}^{K+1},\ldots,e_{n^{K+1}}^{K+1}) = (r,\ldots,e_{n^K}^K)$ is strictly monotonically increasing.

This completes the proof by induction.

Note that the algorithm is tail recursive.
Therefore we can reformulate it as a recursive function.
Instead of jumping back to the start of the loop, we can invoke the algorithm again with
the sequence set to $e_1^K,\ldots,e_{n^K}^K$ and $V$ set to $V - u$.
Recall that we have just proved that this sequence is a valid input for the algorithm and that $e_{i^K}^K$ is the minimum that is being computed in line \ref{a1:minimum}.

\textbf{Part 3}: We can now prove by induction over $n$ that the algorithm computes the water levels.

Step 1: $n = 1$ or $V < u$ during the first iteration of the loop. Note that $n = 1$ implies $V < \infty = u$.

Since the $e_i$ is the single local minimum of the sequence and since it is a strict minimum, all water will flow to $e_i$ until the negative volume below the adjacent segments is used up.
The following image shows the negative volume of an example.
\begin{center}
  \includegraphics{im6.pdf}
\end{center}
Note that $u := (\min(l, r)-e_{i^K}^K)w_i$ is the volume of this space.
By our assumption, $V < u$, that is, all of the water fits into this space.
In line \ref{a1:vplus}, the algorithm increases the height of $e_i$ by $V/w_i$ which is in fact the height a volume $V$ would take up in this space of width $w_i$.

Step 2: Assume that the argument holds for all $\tilde{n} < n$.
For $V < u$ we have already shown the result in step 1.
Otherwise assume $V \ge u$.
Let $u$ be as in the first iteration of the loop, $V_1 = u$, and $V_2 = V - V_1 \ge 0$.
We have shown above that invoking the algorithm with $V$ is the same as running the iteration once and then invoking the algorithm on the resulting sequence with $V = V_2$.
Note that invoking the algorithm with $V_1$ runs the iteration once and then once more with $V = 0$.
However, this second iteration has no effect on the output of the algorithm.
Therefore, invoking the algorithm with $V$ is indentical to invoking the algorithm once with $V = V_1$ and then with $V = V_2$ on the output of the first invocation.
During the first iteration of the invocation with $V = V_1$, we have $V = u \ge u$ in line \ref{a1:vleu}.
Therefore the algorithm outputs a new sequence with length $n^1 < n$.

Note that during the invocation of the algorithm with $V = V_1$ we have $V = u$.
By an argument identical to that in step 1, this invocation computes the elevation level after pouring $V_1$ square units of water into the terrain.
By our induction assumption (since $n^1 < n$), invoking the algorithm with $V = V_2$ on the output of the first invocation calculates the elevation levels after pouring $V_2$ square units of water into the terrain, taking into account the changes in elevation caused by the first $V_1$ square units of water.

Since water in the real world also composes, that is, pouring $V$ square units is the same as pouring $V_1$ square units and then $V_2$ square units (ignoring evaporation etc.), this completes the proof by induction.

\textbf{Part 4}: Lastly we show that the algorithm completes in $\bO(n)$ time.
Computing $i$ in line \ref{a1:minimum} takes $\bO(n)$ time.
Within the loop, performing the merge only touches the elements to the immediate left and right of the local minimum; therefore, assuming an implementation via linked lists, this operation takes $\bO(1)$ time.
All other operations within the loop are clearly $\bO(1)$.
Each iteration of the loop decreases the length of the sequence by at least $1$ and the loop terminates when the length is $1$.
Therefore the loop iterates at most $n$ times.

This completes the proof.

\end{proof}

We can now solve the general problem using the following ansatz.

Let $(e_1,\ldots,e_n)$ be a fully merged elevation sequence.
\begin{center}
  \includegraphics{im8.pdf}
\end{center}
Note that on each local maximum, half of the water flows to the left and half flows to the right.
Split each local maximum in half.
\begin{center}
  \includegraphics{im9.pdf}
\end{center}
We call each of these three components a \textit{sink}.
Note that each sink has a single local minimum.
Fill each sink uniformly and independently until any of the sinks overflows onto one of the bounding local maxima.
\begin{center}
  \includegraphics{im10.pdf}
\end{center}
Fill up the overflowing sink and merge it with the sink on the overflowing side.
\begin{center}
  \includegraphics{im12.pdf}
\end{center}
Note that the merged sink has a single local minimum.
Repeat this process until $T$ is reached.
Note that if only a single sink remains, that sink will never overflow since it has no bounding local maxima.

One special case occurs if the sink overflows on both sides at the same time.
\begin{center}
  \includegraphics{im13.pdf}
\end{center}
In this case the overflowing sink is filled up, split in half, and divided equally between its neighbors.
\begin{center}
  \includegraphics{im14.pdf}
\end{center}

We will now define the sinks of an elevation sequence and its properties.

Let $(e_1,\ldots,e_n)$ be a fully merged elevation sequence and let $k_1,\ldots,k_m \in \{2,\ldots,n-1\}$ be its local maxima.

If the sequence has no local maxima, then it has a single sink $S_1$ containing all of the segments.

Otherwise, split each $e_{k_i}$ into $e_{k_i,1}$ and $e_{k_i,2}$, each having half of the width of $e_{k_i}$.
Then $S_1$ consists of $(e_1,\ldots,e_{k_1,1})$.
For $i\in\{2,\ldots,m\}$, $S_i$ consists of $(e_{k_{i-1},2},\ldots,e_{k_i,1})$.
$S_{m+1}$ consists of $(e_{k_m,2},\ldots,e_n)$.

If $S_i$ has no bounding maxima, then the \textit{bounding height} $\mathcal{B}(S_i)$ of $S_i$ is $\infty$.
Otherwise, if $S_i$ has a single bounding maximum $e_l$, then $\mathcal{B}(S_i)$ is $e_l$.
Otherwise $S_i$ has a two bounding maxima $e_l$ and $e_r$ and $\mathcal{B}(S_i)$ is $\min(e_l, e_r)$.

We write $\mathcal{E}(S_i)$ for the sequence of elevation levels in $S_i$.
For example, $\mathcal{E}(S_i) = (e_{k_{i-1}^2},\ldots,e_{k_i^1})$ for $i\in\{2,\ldots,m\}$.
We write $\mathcal{C}(S_i)$ for the subsequence of $\mathcal{E}(S_i)$ consisting of those $e$ for which $e \le \mathcal{B}(S_i)$.
We write $\norm{\mathcal{E}(S_i)}$ for the number of elements in $\mathcal{E}(S_i)$ and $\norm{\mathcal{C}(S_i)}$ for the number of elements in $\mathcal{C}(S_i)$.

It is clear that, since $\mathcal{E}(S_i)$ contains no local maximum, $\mathcal{C}(S_i)$ is a continuous subsequence of $\mathcal{E}(S_i)$.
That is, if $e_a$, $e_b$, and $e_c$ are in $\mathcal{E}(S_i)$ in that order, and $e_a$ and $e_c$ are in $\mathcal{C}(S_i)$, then $e_b\in\mathcal{C}(S_i)$.
Let $e_l$ and $e_r$ be the first and last elements in $\mathcal{E}(S_i)$.
By the definition of $\mathcal{B}(S_i)$, $e_l\le\mathcal{B}(S_i)$ or $e_r\le\mathcal{B}(S_i)$.
Therefore $e_l\in\mathcal{C}(S_i)$ or $e_r\in\mathcal{C}(S_i)$.

If $e_l,e_r\in\mathcal{C}(S_i)$, then we say that $S_i$ overflows on both sides.
Otherwise, if $e_l\in\mathcal{C}(S_i)$, we say that $S_i$ overflows on the left.
Otherwise we say that $S_i$ overflows on the right.

For each segment $e\in\mathcal{E}(S_i)$, let $\mathcal{W}(e)$ be the corresponding width.
We define the \textit{capacity} $\capp(S_i)$ of a sink as follows:
\begin{align*}
    \capp(S_i) = \sum_{e\in\mathcal{C}(S_i)} \mathcal{W}(e)(\mathcal{B}(S_i)-e).
\end{align*}
Note that $\capp(S_i)$ is the volume of water $S_i$ can hold before it overflows.

We define the \textit{width} $\mathcal{W}(S_i)$ of $S_i$ by
\begin{align*}
    \mathcal{W}(S_i) = \sum_{e\in\mathcal{E}(S_i)} \mathcal{W}(e).
\end{align*}
We define the \textit{capacity width} $\mathcal{W}_c(S_i)$ of $S_i$ by
\begin{align*}
    \mathcal{W}_c(S_i) = \sum_{e\in\mathcal{C}(S_i)} \mathcal{W}(e).
\end{align*}

At certain points in the algorithm, we compute for a sink $S_i$ how much water is currently in the sink.
At these points we store the time since it has started raining and the computed value.
We call these values $\filltime(S_i)$ and $\Fill(S_i)$ respectively.
Initially both values are $0$.

For each sink $S_i$, we calculate the time (in hours) at which it will overflow, $\ot(S_i)$, as follows:
\begin{align*}
    \ot(S_i) = \frac{\capp(S_i) - \Fill(S_i)}{\mathcal{W}(S_i)} + \filltime(S_i).
\end{align*}
It is clear that if a sink has capacity $\capp(S_i)$ of which $\Fill(S_i)$ is already used, then the remaining capacity for additional water is $\capp(S_i) - \Fill(S_i)$.
Since the sink receives $\mathcal{W}(S_i)$ square units of water per hour, this additional capacity is used up after $\frac{(\capp(S_i) - \Fill(S_i))}{\mathcal{W}(S_i)}$.
Since this additional rain occurs after the time $\filltime(S_i)$, we have to add $\filltime(S_i)$ to get the absolute time value.

We define a total order on the sinks $S_i$ by the lexicographic order on the tuples $(\ot(S_i), i)$.
That is, sinks that overflow earlier come first.
If two sinks overflow at the same time, the sink with the smaller index comes first.

In our algorithm, we will maintain a priority queue containing all sinks.
Popping an element from this queue always returns the sink that comes first in the order defined above.
That is, it always returns the sink that overflows next.

Some of the properties above require more than $\bO(1)$ time to be computed.
In these cases, we will assume that the propertise are calculated once and then cached.
When merging two sinks we will re-calculate the cached values.

In our algorithm, we we will maintain doubly-linked lists of elevation segments and sinks.
Both of these lists contain their elements from left to right in the terrain.
When we say that we remove one or more elevation segments or sinks, we mean removing them from these linked lists.

\begin{thm}
    Let $n\in\Np$, $T\in\Rnn$, and let $(e_1,\ldots,e_n)$ be a fully merged elevation sequence.
    Then the following algorithm calculates the water levels at time $T$ in $\bO(n\log(n))$ time.
\end{thm}

\vspace{1em}

\begin{algorithmic}[1]
    \State Let $(S_i)_i$ be the sinks of $(e_1,\ldots,e_n)$
    \State Let $B$ be a priority queue containing the sinks as described above
    \State $c := 0$
    \While{true} \label{a2:while}
        \State Pop a sink $S$ from $B$
        \If{$\ot(S)\ge T$}
            \State break
        \EndIf
        \State $c := \ot(S)$
        \If{$S$ overflows on both sides}
            \State Let $S_l$ be the sink to the left of $S$
            \State Let $S_r$ be the sink to the right of $S$
            \State $\Fill(S_l) := \Fill(S_l) + (c - \filltime(S_l))\mathcal{W}(S_l)$
            \State $\Fill(S_r) := \Fill(S_r) + (c - \filltime(S_r))\mathcal{W}(S_r)$
            \State $\filltime(S_l) := c$
            \State $\filltime(S_r) := c$
            \State Let $e_r$ be the rightmost segment in $S_l$
            \State Let $e_l$ be the leftmost segment in $S_r$
            \State Remove all segments between $e_r$ and $e_l$
            \State $w := \mathcal{W}(e_r) + \mathcal{W}(e_l) +\mathcal{W}(S)$
            \State $d_r := w/2 - \mathcal{W}(e_r)$
            \State $d_l := w/2 - \mathcal{W}(e_l)$
            \State $\mathcal{W}(e_r) := \mathcal{W}(e_r) + d_r$
            \State $\mathcal{W}(e_l) := \mathcal{W}(e_l) + d_l$
            \State $\mathcal{W}(S_l) := \mathcal{W}(S_l) + d_r$
            \State $\mathcal{W}(S_r) := \mathcal{W}(S_r) + d_l$
            \If{$\mathcal{C}(S_l)$ ends in $e_r$}
              \State $\mathcal{W}_c(S_l) := \mathcal{W}_c(S_l) + d_r$
            \EndIf
            \If{$\mathcal{C}(S_r)$ ends in $e_l$}
              \State $\mathcal{W}_c(S_r) := \mathcal{W}_c(S_r) + d_l$
            \EndIf
            \State Remove $S$.
            \State Recalculate $\ot(S_l)$
            \State Recalculate $\ot(S_r)$
        \Else
            \If{$S$ overflows on the left}
              \State Let $S_m$ be the sink to the left of $S$
            \Else
              \State Let $S_m$ be the sink to the right of $S$
            \EndIf
            \State $\Fill(S_m) := \Fill(S_m) + (c - \filltime(S_m))\mathcal{W}(S_m)$
            \State $\filltime(S_m) := c$
            \State Remove the elements of $\mathcal{C}(S)$
            \State Extend $\mathcal{E}(S_m)$ to contain $\mathcal{E}(S)$
            \State $\mathcal{W}(S_m) := \mathcal{W}(S_m) + \mathcal{W}(S)$
            \If{$S$ overflows on the left}
              \State Let $e_r$ be the rightmost segment in $S_m$
              \State $\mathcal{W}(e_r) := \mathcal{W}(e_r) + \mathcal{W}_c(S)$
              \If{$\mathcal{C}(S_m)$ ends in $e_r$}
                \State $\mathcal{W}_c(S_m) := \mathcal{W}_c(S_m) + \mathcal{W}_c(S)$
              \EndIf
            \Else
              \State Let $e_l$ be the leftmost segment in $S_m$
              \State $\mathcal{W}(e_l) := \mathcal{W}(e_l) + \mathcal{W}_c(S)$
              \If{$\mathcal{C}(S_m)$ ends in $e_l$}
                \State $\mathcal{W}_c(S_m) := \mathcal{W}_c(S_m) + \mathcal{W}_c(S)$
              \EndIf
            \EndIf
            \State $b := \mathcal{B}(S_m)$
            \State Recalculate $\mathcal{B}(S_m)$
            \If{$\mathcal{B}(S_m) > b$}
              \State $\capp(S_m) := \capp(S_m) + \mathcal{W}_c(S_m)(\mathcal{B}(S_m) - b)$
              \While{true}
                \State Let $e$ be the first segment to the left of $\mathcal{C}(S_m)$
                \If{$e > \mathcal{B}(S_m)$ or $e$ is outside of $\mathcal{E}(S_m)$}
                    \State break
                \EndIf
                \State $\mathcal{W}_c(S_m) := \mathcal{W}_c(S_m) + \mathcal{W}(e)$
                \State $\capp(S_m) := \capp(S_m) + \mathcal{W}(e)(\mathcal{B}(S_m) - e)$
                \State Extend $\mathcal{C}(S_m)$ to contain $e$
              \EndWhile
              \While{true}
                \State Let $e$ be the first segment to the right of $\mathcal{C}(S_m)$
                \If{$e > \mathcal{B}(S_m)$ or $e$ is outside of $\mathcal{E}(S_m)$}
                    \State break
                \EndIf
                \State $\mathcal{W}_c(S_m) := \mathcal{W}_c(S_m) + \mathcal{W}(e)$
                \State $\capp(S_m) := \capp(S_m) + \mathcal{W}(e)(\mathcal{B}(S_m) - e)$
                \State Extend $\mathcal{C}(S_m)$ to contain $e$
              \EndWhile
            \EndIf
            \State Remove $S$.
            \State Recalculate $\ot(S_m)$
        \EndIf
    \EndWhile
    \For{each sink $S$ in the linked list}
      \State $\Fill(S_l) := \Fill(S_l) + (T - \filltime(S_l))\mathcal{W}(S_l)$
      \State Detach $\mathcal{E}(S)$ from the rest of the linked list
      \State Apply the algorithm from Lemma \ref{alg1} to $\mathcal{E}(S)$ with $V = \Fill(S_l)$
      \State Insert the output into the linked list in the place where we just detached $\mathcal{E}(S)$
    \EndFor
    \State The linked list of segments are the desired elevation levels.
\end{algorithmic}

\end{document}
